create table salesperson(
	name varchar2(20) primary key,
	age number,
	salary number
);

create table customer(
	name varchar2(20) primary key,
	city varchar2(20),
	industrytype varchar2(20)
);

create table orders(
	no number,
	custname varchar2(20) references customer(name),
	salesperson varchar2(20) references salesperson(name),
	amount number,
	primary key(custname, salesperson)
);

insert into salesperson values('김수연', 26, 500);
insert into salesperson values('임하연', 37, 500);
insert into salesperson values('유하림', 40, 600);
insert into salesperson values('이건우', 50, 700);
insert into salesperson values('박지예', 27, 500);

insert into customer values('최현호', '서울', '공무원');
insert into customer values('김지현', '서울', 'IT');
insert into customer values('윤서우', '서울', 'IT');
insert into customer values('정자영', '서울', '교사');
insert into customer values('윤태인', '인천', '서비스업');
insert into customer values('김시아', '인천', '서비스업');
insert into customer values('노유나', '대전', '건설');
insert into customer values('박성미', '광주', '건설');
insert into customer values('임상진', '대전', '교사');

insert into customer values('안철수', '서울', '기업인');
insert into customer values('윤석열', '서울', '정치인');

insert into salesperson values('이재명', 50, 400);

**  시퀀스
컬럼의 종류가 숫자인경우
	알아서 자동으로 1부터 1씩 증가하는 값으로 순번을 매겨야 하는 경우에 사용합니다.
	
** 시퀀스 만든 방법
create sequence 시퀀스이름;

** 시퀀스를 사용하는 방법
insert into 테이블이름 values( 시퀀스이름.nextval, ...)


create sequence seq_orders;

insert into orders values(seq_orders.nextval,  '최현호', '김수연', 1 );
insert into orders values(seq_orders.nextval,  '김지현', '김수연', 1 );
insert into orders values(seq_orders.nextval,  '윤서우', '김수연', 1 );

insert into orders values(seq_orders.nextval,  '정자영', '임하연', 1 );
insert into orders values(seq_orders.nextval,  '윤태인', '임하연', 1 );

insert into orders values(seq_orders.nextval,  '김시아', '유하림', 1 );

insert into orders values(seq_orders.nextval,  '노유나', '이건우', 1 );
insert into orders values(seq_orders.nextval,  '박성미', '박지예', 1 );
insert into orders values(seq_orders.nextval,  '임상진', '박지예', 1 );

insert into orders values(seq_orders.nextval,'최현호', '박지예',1);
insert into orders values(seq_orders.nextval, '최현호', '이건우',1);
insert into orders values(seq_orders.nextval, '김시아', '박지예', 1);

** 시퀀스를 이용하여 
			만약 sql명령자체에 결함이 있어 
			실패했을때는
			시퀀스를 이용한 순번은 이미 발행이 되었기 때문에 
			순서대로 되지 않을 수 있어요!
			
			꼭, 순서대로 해야 한다면 
			max(컬럼) + 1 를 사용합니다.
			
			시퀀스는 겹치지 않도록 번호를 매기는 용도로 사용합니다.
			
1) 
2) 모든 판매원의 이름과 급여를 출력, 단 중복행은 제거한다.
		select  distinct  name, salary from salesperson;


3) 나이가 30세 미만인 판매원의 이름을 출력
		select name from salesperson where age < 30;

4) '주'로 끝나는 도시에 사는 고객의 이름을 출력
	select name from customer where city like '%주';
	
5) 주문을 한 고객의 수(서로 다른 고객) 를 출력
		select count( distinct custname) from orders;		

6) 판매원 각각에 대하여 주문의 수를 계산하시오.
		select salesperson, count(*) from orders
			group by salesperson;

	 각 판매원별로 총 주문 수량을 출력
	 		select salesperson, sum(amount) from orders
			group by salesperson;

	SQL> select salesperson, sum(amount) from orders
  2  group by salesperson;

SALESPERSO SUM(AMOUNT)
---------- -----------
김수연              12
임하연               2
유하림               1
이건우               6
박지예               4

SQL> select salesperson, count(*) from orders
  2  group by salesperson;

SALESPERSO   COUNT(*)
---------- ----------
박지예              4
유하림              1
김수연              3
이건우              2
임하연              2


7)  "서울"에 사는 고객으로 부터 주문을 받은 판매원의 이름과 나이를 출력 (서브쿼리)
	- '서울'에 사는 고객이름 출력
		select name from customer where city = '서울';
		==> A
		
	- A에게 판매만 판매원의 이름 출력
	select distinct salesperson from orders where custname in (  select name from customer where city = '서울');
		==> B
		
	- 이름이 B에 해당하는 판매원이름과 나이를 출력
	select name, age from salesperson
	where name in (select distinct salesperson from orders where custname in (  select name from customer where city = '서울'));
	
	NAME         AGE
		---------- -----
		김수연        26
		임하연        37
		이건우        50
		박지예        27

8)  "서울"에 사는 고객으로 부터 주문을 받은 판매원의 이름과 나이를 출력 (조인)

select distinct s.name, age 
from salesperson s, orders o, customer c
where s.name = o.salesperson and 
c.name = o.custname and 
city = '서울';

NAME         AGE
---------- -----
김수연        26
임하연        37
이건우        50
박지예        27




9)  두번이상 주문을 받은 판매원의 이름을 출력
select salesperson, count(salesperson) from orders 
group by salesperson
having count(salesperson) >=2;

10)  판매원 '박지예'의 급여를 600으로 변경하는 sql명령어를 작성
update salesperson set salary = 600 where name = '박지예';


-------------------------------------------------------------------------------------------------------------
데이터베이스 명령의 종류
	1. DCL(Data Control language)		데이터 제어어
					권한부여, 권한을 제거하는 명령어
					grant, revoke
					
	2. DDL(Data Definition language)		데이터 정의어
				테이블(뷰,인덱스)을 생성, 삭제, 수정
				create, drop, alter
				
	3. DML(Data Manupulation Langugae) 데이터 조작어
			자료를 추가, 검색, 수정, 삭제
			insert, select, update, delete
			
----------------------------------------------------------------------------------------------------

** 서브쿼리에 대하여 설명하시오.
		sql명령어 안에 포함되는 또다른 sql을 말합니다.
		
** 서브쿼리는 sql명령어의 어디에 올 수있나요?
	서브쿼리는 select절 올 수도 있고
	from 올수도 있고
	where 절에 올 수도 있습니다.
	
---------------------------------------------------------------------------------------------------

** 다중행 연산자에 대하여 설명하시오.
	서브쿼리가 where 절에 사용일 될때에 
	서브쿼리의 건수가 여러건일때에 사용하는 연산자 입니다.

** 다중행 연산자의 종류는 어떤것들이 있나요?
	in, not in, any(some), all, exists, not exists 가 있습니다.

----------------------------------------------------------------------------------------------------------
연습) 대한민국에 거주하는 고객에게 판매한 도서의 총판매액을 출력

- 대한민국에 거주하는 고객의 번호 출력
select custid from customer where address like '대한민국%';
===> A

- 주문테이블로 고객번호가 A에 해당하는 판매액의 총합을 출력
select sum(saleprice) from orders 
	where custid   =  (select custid from customer where address like '대한민국%');

	SQL> select sum(saleprice) from orders
  2  where custid   =  (select custid from customer where address like '대한민국%');
where custid   =  (select custid from customer where address like '대한민국%')
                   *
2행에 오류:
ORA-01427: 단일 행 하위 질의에 2개 이상의 행이 리턴되었습니다.
-------------------------------------------------------------------------------------------------------------------------------
select sum(saleprice) from orders 
	where custid   in  (select custid from customer where address like '대한민국%');


===> 서브쿼리 건수가 여러건 일때에는 
			= 대신에 
			in을 사용해야 합니다.
		
-------------------------------------------------------------------------------------------------------------------------------------------------
연습) 3번 고객이 주문한 도서의 최고 금액보다 더 비싼 도서를 구입한 주문의 주문번호와 금액을 출력
- 3번고객이 주문한 주문금액을 출력
	select saleprice from orders where custid = 3;
	SALEPRICE
	---------
	    6,000
	   12,000
	   13,000
	   10,000
	   10,000
	   10,000
	   10,000						===> A
	   
	- 주문테이블로 부터 주문가격이 A보다 큰 주문의 주문번호, 주문금액을 출력
	select orderid, saleprice from 
	orders where saleprice > (select saleprice from orders where custid = 3);
	
  SQL> select orderid, saleprice from
  2  orders where saleprice > (select saleprice from orders where custid = 3);
orders where saleprice > (select saleprice from orders where custid = 3)
                          *
2행에 오류:
ORA-01427: 단일 행 하위 질의에 2개 이상의 행이 리턴되었습니다.

===> 서브쿼리의 건수가 여러건 이어서 비교연산 > 를 사용할 수 없어요!
			다중행 연산자인 any(some), all과 같이 사용해야 합니다.

------------------------------------------------------------------------------------------------------
select orderid, saleprice from 
	orders where saleprice > all (select saleprice from orders where custid = 3);

select orderid, saleprice from 
	orders where saleprice > (select max(saleprice) from orders where custid = 3);

==> 
	> all은 
	max함수를 사용하여 단일행 연산자로 표현할 수 있어요!
	
-----------------------------------------------------------------------------------------------------------

select  orderid, saleprice from 
	orders where saleprice > any (select saleprice from orders where custid = 3);

select  orderid, saleprice from 
	orders where saleprice > some (select saleprice from orders where custid = 3);	
	
===> 
	> some(any)는 
		min함수를 사용하여 단일행 연산자로 표현할 수 있어요
		
select  orderid, saleprice from 
	orders where saleprice >  (select min(saleprice) from orders where custid = 3);





--------------------------------------------------------------------------------------------------------------

연습) 출판사별 평균가격의 최대값 보다 더 비싼 도서의 정보를 출력합니다.
			max함수를 사용하여 단일행 연산자 이용
			다중행연산자 이용

- 출판사별 도서의 평균가격 출력
select avg(price) from book group by publisher;
AVG(PRICE)
----------
     10250
     13000
     28500
     17000
      7500
     13000
32333.3333
====> A

- book테이블로 부터 price가 A보다 큰 값의 도서를 출력
select * from book where price > all (select avg(price) from book group by publisher);
select * from book where price > (select max(avg(price)) from book group by publisher);

-----------------------------------------------------------------------------------------------------------------------------
** 다중행 연산자 
		in, not in, any(some), all에 각각 설명하시오
		
		in, not in, any(some), all 모두
		서브쿼리의 건수가 여러건 일 때 사용하며 
		
		in은 =을 대신하여 사용하며
		not in !=을 대신하여 사용하며
		
		any(some), all은 
		>, <, >=, <= 연산자와 함께 사용합니다.
		
		any(some), all은 
		min함수나 max함수를 사용하면
		단일행 연산자로도 표현할 수 있어요.
---------------------------------------------------------------------------------------------------------------------------------------
exists, not exists 연산자
	다중행 연산자 종류중의 하나이며
	서브쿼리의 건수가 존재하는지 존재하지 않은지 여부를 판별하는 연산자 입니다.
	
	exists 는 서브쿼리가 반환하는 조건에 맞는 메인쿼리를 실행하고
	not exists는 서브쿼리의 조건에 만족하지 않는 메인쿼리를 실행합니다.
	
	exists, not exists 다중행 연산자를 사용할 때에는 
	반드시 상관서브쿼리 이어야 합니다.
	
-----------------------------------------------------------------------------------------------------------------------------------

연습) 대한민국에 거주하는 고객에게 판매한 도서의 총판액을 출력

- join
	select sum(saleprice) from
		customer c, orders o
		where c.custid = o.custid and 
		address like '대한민국%';

		==>249500

- in 연산자 이용 서브쿼리
	select sum(saleprice) 
	from orders 
	where custid in  (select custid from customer where address like '대한민국%');
	
	==> 249500

- exits 연산자 이용 서브쿼리
	select sum(saleprice)
	from orders o
	where  exists  (  select custid from customer c where address like '대한민국%' and o.custid = c.custid)
		
	==> 249500

-----------------------------------------------------------------------------------------------------------------------------------------------
View
		==> 실제로는 존재 하지 않는 논리적인 가상의 테이블을 말합니다.
		==> 자주사용하는 복잡한 조건식을 갖는 select문이 있다면
					그것을 조회하는 sql명령를 뷰로 만들어놓으면
					사용이 용이합니다.
		==> 보안유지상 특정 테이블의 칼럼을 제한하여 접근할 수 있도록 
				할때에도 뷰를 사용합니다.
								
------------------------------------------------------------------------------------------------------------------------
** 뷰를 만드는 방법

create view 뷰이름
as select 문

연습) 오늘날짜의 출판사별 총판매수량, 총판매금액을 출력
	select publisher, count(publisher) cnt, nvl(sum(saleprice),0) sum
	from book b, orders o
	where b.bookid = o.bookid(+) and 
	to_char(orderdate, 'yyyy/mm/dd') = to_char(sysdate,'yyyy/mm/dd')
	group by publisher;
	===> A

	select distinct publisher, 0 cnt from book;
	==> B
	
	A의cnt + B의 cnt
	
	select b.publisher, nvl(A.cnt,0) cnt, nvl(A.sum, 0) sum from 
	(select publisher, count(publisher) cnt, nvl(sum(saleprice),0) sum
	from book b, orders o
	where b.bookid = o.bookid(+) and 
	to_char(orderdate, 'yyyy/mm/dd') = to_char(sysdate,'yyyy/mm/dd')
	group by publisher) A right outer join (select distinct publisher, 0 cnt from book) B
	on A.publisher = B.publisher
	order by nvl(A.cnt,0) desc;
	
	==> 위와같이 조회할 일이 많다고 할 때에 
	매번 sql를 작성하는 것은 번거로운 일입니다.
	
	이런경우 뷰를 만들어두면 조회를 쉽게 할 수 있어요.
	
	create view today_sale 
	as 				
	select b.publisher, nvl(A.cnt,0) cnt, nvl(A.sum, 0) sum from 
	(select publisher, count(publisher) cnt, nvl(sum(saleprice),0) sum
	from book b, orders o
	where b.bookid = o.bookid(+) and 
	to_char(orderdate, 'yyyy/mm/dd') = to_char(sysdate,'yyyy/mm/dd')
	group by publisher) A right outer join (select distinct publisher, 0 cnt from book) B
	on A.publisher = B.publisher
	order by nvl(A.cnt,0) desc;

	select * from today_sale;






---------------------------------------------------------------------------------------------------------------------------------

연습) 도서명에 "축구"를 포함하고 있는 도서의 정보를 조회하는 
				뷰를 생성해 봅니다.		
				뷰이름은 vw_book이라고 합니다.
				
			create view vw_book
			as 
			select * from book
			where bookname like '%축구%';	


연습) '대한민국'에 거주하는 고객의 정보를 출력하는 뷰를 생성합니다.
				(vw_customer)
			
			create view vw_customer 
			as 
			select * from customer 
			where address like '대한민국%';
				
연습)  주문번호, 고객번호, 고객이름, 도서번호, 도서명, 판매가격, 주문일을 
				출력하는 view를 생성합니다.   vw_orders
				
create view vw_orders
as 
select orderid, c.custid, name, b.bookid, bookname, saleprice, orderdate
from customer c, orders o, book b
where c.custid = o.custid and
b.bookid = o.bookid;			
								

연습) vw_orders를 통해서 '김연아'고객의 주문내역 조회
select * from vw_orders 
where name = '김연아';

------------------------------------------------------------------------------------------------------------------------
** view 사용하는 목적
		- 자주사용하는 복잡한 sql를 대신
		- 보안유지상 사용자별로 조회할 수 있는 컬럼을 제한
		
		

실습을 위하여 사용자 계정을 만들어 봅시다.

create user c##hong identified by hong;
grant connect, resource to c##hong;


연습) c##madang이 
				자신의 테이블인 emp중에서
				사원번호, 사원명, 부서번호, 주소,전화번호만
				조회할 수 있도록 뷰를 생성하여 
				c##hong에게 권한을 부여 해 봅시다.
				vw_emp
	
create view vw_emp
as 
select eno, ename, dno, addr,phone 
from emp;

** 권한부여
grant select on c##madang.vw_emp to c##hong;

** 권한제거
revoke select on c##madang.vw_emp from c##hong;

-----------------------------------------------------------------------------------------------------------
연습) 20번 부서에 근무하는 
				직원들의 사원번호, 사원명, 주소,전화,부서번호를 조회하는 뷰를 생성
				(vw_emp20)
				
create view vw_emp20
as 
select eno,ename,addr, phone, dno 
from emp
where dno = 20;			

** 뷰를통하여 insert, update, delete를 실험해 봅니다.

insert into vw_emp20 values(2000, '홍길동', '서울', '010-7777-7777', 20);
==> 뷰를 통하여 insert할 수 있어요.
			실제로 레코드는 뷰를 생성할 때 사용한 모테이블에 추가됩니다.
			그렇기 때문에 뷰생성시에 사용한 컬럼 이외의 칼럼들은 null을 허용하거나 default값이 설정되어 있어야 합니다.
			
update vw_emp20 set addr = '서울' where eno= 1010;
==> 뷰를 통하여 update를 할 수 있어요.
			뷰 생성시에 사용한 모테이블의 내용이 수정됩니다.
			

delete vw_emp20 where eno = 1014;			
==> 뷰를 통하여 delete를 수행 할 수 있어요.
				실제 레코드가 있는 모테이블에서 삭제가 수행됩니다.
				
				
----------------------------------------------------------------------------------------------------------------------
연습) 뷰를생성시의 조건에 맞지 않는 레코드를 추가 할 수 있는지 실험 해 봅니다.	
insert into vw_emp20 values(3000, '이순신', '서울', '010-9999-9999', 30);	
	
	===> 뷰를 생성시에 조건에 맞지 않는 레코드를 추가 할 수 있어요.
					그러나 뷰에는 나타지않고 
					모테이블에 추가 되었습니다.
					
연습) 뷰를 생성시에 조건에 맞지 않는 값으로 레코드를 수정할 수 있는지 실험 해 봅니다.
update vw_emp20 set dno =30 where eno = 2000;
		==> 뷰를 생성시 설정한 조건에 맞지 않은 값을 뷰를통해 update할 수 있어요.
					모테이블의 내용이 변경되고 뷰에는 조건에 맞지 않기 때문에 나타나지 않아요.


-----------------------------------------------------------------------------------------------------------------------		
** 뷰를 삭제하는 방법
drop view 뷰이름;

					
------------------------------------------------------------------------------------------------------------------------------
** 뷰를 생성시에 설정한 
			조건에 맞지 않는 레코드를 추가할 수 없도록
			조건에 맞지 않는 값으로 수정할 수 없도록 
			하고싶어요!!
	
	create view 뷰이름 as select ~~ 조건식 with check option;
	
	with check option를 설정하여 뷰를 생성한 다음
	조건에 맞지 않는 레코드를 추가하고 
	조건에 맞지 않는 값으로 수정 해 봅니다.
	
	create view vw_emp20
	as 
	select eno,ename,addr,phone,dno
	from emp
	where dno =20
	with check option;
	
	insert into vw_emp20 values(4000, '유관순', '서울', 010-0000-0000, 20);
	insert into vw_emp20 values(5000, '문재인', '서울', 010-0000-0000, 30);

	insert into vw_emp20 values(5000, '문재인', '서울', 010-0000-0000, 30)
            *
	1행에 오류:
	ORA-01402: 뷰의 WITH CHECK OPTION의 조건에 위배 됩니다
	==> 뷰 생성시에 with check option을 주었기 때문에 
					조건에 맞지 않는 레코드를 추가 없어요!
					
	update vw_emp20 set phone = '010-2222-2222' where eno = 4000;			
	update vw_emp20 set dno = 30 where eno = 1010;

SQL> update vw_emp20 set dno = 30 where eno = 1010;
update vw_emp20 set dno = 30 where eno = 1010
       *
1행에 오류:
ORA-01402: 뷰의 WITH CHECK OPTION의 조건에 위배 됩니다

---------------------------------------------------------------------------------------------------------------------------
조회(읽기)만 가능한 뷰를 생성
	create view 뷰이름 as select ~~  with read only;
	
연습) vw_emp20을 삭제하고 읽기만 가능한 뷰로 만들어 
				데이터를 추가,수정,삭제,조회를 실험해 봅니다.
				
create view vw_emp20
as
select eno, ename, addr, phone, dno
from emp
where dno = 20
with read only;				

select * from vw_emp20;
insert into vw_emp20 values(4001, '김유신', '서울', '010-2222-2222', 20);
1행에 오류:
ORA-42399: 읽기 전용 뷰에서는 DML 작업을 수행할 수 없습니다.

update vw_emp20 set addr = '인천' where eno = 1010;
1행에 오류:
ORA-42399: 읽기 전용 뷰에서는 DML 작업을 수행할 수 없습니다.

delete vw_emp20 where eno = 4000;
1행에 오류:
ORA-42399: 읽기 전용 뷰에서는 DML 작업을 수행할 수 없습니다.

-----------------------------------------------------------------------------------------------------------------------------

** view에 대하여 설명하시오.
	실제로는 존재하지 않는 가상의 논리적인 테이블을 말하며 
			복잡한 sql를 대신하거나
			사용자별 접근권한을 설정하는 용도로 사용합니다.
			
			뷰를 통해서 추가,수정,삭제가 가능하며
			
			with check option를 설정하여 조건에 맞는 레코드만 추가,수정할 수 있도록 하고
			with read only 옵션을 설정하여 읽기만 가능한 뷰를 만들 수 있어요.
			
-----------------------------------------------------------------------------------------------------------
	시스템 뷰
		==> 오라클이 제공하는 데이터사전을 말합니다.
		
		user_obejcts						사용자가 만든 모든 객체의 정보를 갖고 있어요.
		user_tables							사용자 가 만든 모든 테이블의 정보를 갖고 있어요.
		user_constraints					사용자가 만든 모든 제약의 정보를 갖고 있어요.
			
	
	==> 제약의 비활성화
		alter table 테이블이름 disable constraint 제약명;
	
	==> 제약의 활성화
		alter table 테이블이름 enable constraint 제약명;
		
	SYS_C008320     R                    ORDERS     ENABLED
	SYS_C008319     R                    ORDERS     ENABLED	
	SYS_C008316     P                    BOOK       ENABLED	
		
	insert into book values(14, '즐거운 오라클', '쌍용미디어', 30000);
	
	*
	1행에 오류:
	ORA-00001: 무결성 제약 조건(C##MADANG.SYS_C008316)에 위배됩니다
	
-------------------------------------------------------------------------------------------------------
	alter table orders disable constraint SYS_C008320;
	alter table orders disable constraint SYS_C008319;
	alter table book disable constraint SYS_C008316;

 select constraint_name, constraint_type, table_name, status from user_constraints;

insert into book values(14, '즐거운 오라클', '쌍용미디어', 30000);

==> 제약을 활성화를 하려면
			활성화 하려는 제약에대하여 
			만족하는 상태로 만들어야 합니다.

alter table book enable constraint 	SYS_C008316;
alter table orders enable constraint SYS_C008319;
alter table orders enable constraint SYS_C008320;


SQL> alter table book enable constraint SYS_C008316;
alter table book enable constraint SYS_C008316
*
1행에 오류:
ORA-02437: (C##MADANG.SYS_C008316)을 검증할 수 없습니다 - 잘못된 기본 키입니다
===> 활성화 하려는 제약에 대한 만족하지 않는 데이터 있어서 오류가 발생합니다.

delete book where bookname '재미있는 자바';

SQL> alter table book enable constraint SYS_C008316;

테이블이 변경되었습니다.

SQL> alter table orders enable constraint SYS_C008319;

테이블이 변경되었습니다.

SQL> alter table orders enable constraint SYS_C008320;

테이블이 변경되었습니다.






insert into book values(14, '재밌는 웹', '쌍용미디어', 35000);

SQL> insert into book values(14, '재밌는 웹', '쌍용미디어', 35000);
insert into book values(14, '재밌는 웹', '쌍용미디어', 35000)
*
1행에 오류:
ORA-00001: 무결성 제약 조건(C##MADANG.SYS_C008316)에 위배됩니다

===> 제약이 활성화 되어 동일한 도서번호의 레코드를 추가할 수 없어요

-----------------------------------------------------------------------------------------------------------------
인덱스 
	==> 조건식에 자주 사용되는 칼럼에 대하여 
			미리 색인표를 만들어 두는 것을 말합니다.
			인덱스를 만들어두면 검색시에 빠른 성능을 기대할 수 있어요.
			
	어떤 책이 한권 있다고 가정 합시다.
			책이 穿틸. 10페이지도 안돼요
			이런경우에는 굳이 색인표를 만들필요가 없어요.
			책이 굉장히 두꺼워요 한 600페이지 1000페이지 정도 된다면
			책의 내용을 빠르게 찾도록 책 맨뒤에 "색인표"를 만들어두면 
			원하는 내용을 빨리 찾을 수 있어요.
			
		마치 이것처럼
		데이터양 많을 때 
		검색(조건식)에 빈번히 사용하는 칼럼에 대하여 
		"인덱스"를 만들어두면 
		검색시에 성능효과를 기대할 수 있어요!
		
		데이터양이 적으면
		"인덱스"가 있으나 
		없으나 성능효과를 체감하기는 어려워요
		
		만약에 
		책을만들어 놓고 
		책 맨뒤에 "색인표"까지 만들어 두었는데
		책 내용이 빈번히 바뀐다면
		"색인표"는 의미가 없어지고 
		오히려 찾기가 어려워져요!
		
		마찬가지로
		데이터의 수정,삭제가 빈번한 칼럼에 
		"인덱스"를 만들어 두면
		오히려 "성능저하"의 요인이 됩니다.
		
** 인덱스 만드는 방법
create index 인덱스이름 on 테이블이름 (컬럼이름,[컬럼이름])		

연습) bookname을 대상으로 인덱스를 생성 (idx_book)
			- 인덱스를 만들지 않고 책이름으로 검색
			- 인덱스를 만든 후 책이름으로 검색
	
	
	create index idx_book on book(bookname);
	
	
	** 인덱스 삭제		
	drop index 인덱스명;					


---------------------------------------------------------------------------------------------------------------------------------------------------

** 인덱스가 있어서 검색속도 차이 나는것을 보고 싶어요!

member에 
		dummy 데이터 500000명의 데이터를 
		insert하는 프로그램을 만들어 봅시다.
		
		
create table member100(
	id varchar2(50) primary key, 
	pwd varchar2(50),
	name varchar2(50)
);

----------------------------------------------------------------------------------------------------
숙제1) 이번주에 학습한 내용을 요약하여 정리합니다.
숙제2) 입학해서 오늘까지 요약한 것을 전부 복습합니다.